<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Music Intensity Editor</title>
  <style>
    body { font-family: sans-serif; text-align: center; padding: 20px; }
    canvas { border: 1px solid #ccc; display: block; margin: 20px auto; }
    #waveform { cursor: crosshair; }
    #controls { margin: 10px; }
  </style>
</head>
<body>
  <h1>Music Intensity Editor</h1>
  <input type="file" accept="audio/mp3" id="audioInput">
  <div id="controls">
    <button id="playBtn" disabled>Play</button>
    <button id="pauseBtn" disabled>Pause</button>
    <button id="exportBtn" disabled>Export as CSV</button>
  </div>
  <canvas id="waveform" width="800" height="200"></canvas>

  <script>
    const canvas = document.getElementById('waveform');
    const ctx = canvas.getContext('2d');
    const audioInput = document.getElementById('audioInput');
    const playBtn = document.getElementById('playBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const exportBtn = document.getElementById('exportBtn');

    let audioBuffer, duration = 0, audioElement = null;
    let points = [];
    let animationId = null;

    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    audioInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      // Load audio into HTMLAudioElement
      if (audioElement) {
        audioElement.pause();
        audioElement.remove();
      }
      audioElement = new Audio(URL.createObjectURL(file));
      audioElement.controls = false;
      audioElement.load();
      audioElement.addEventListener('canplay', () => {
        playBtn.disabled = false;
        pauseBtn.disabled = false;
        exportBtn.disabled = false;
        duration = audioElement.duration;
      });

      // Decode audio for waveform
      const arrayBuffer = await file.arrayBuffer();
      audioCtx.decodeAudioData(arrayBuffer, buffer => {
        audioBuffer = buffer;
        duration = buffer.duration;
        drawWaveform(buffer);
      });
    });

    function drawWaveform(buffer) {
      const raw = buffer.getChannelData(0);
      const step = Math.floor(raw.length / canvas.width);
      const amp = canvas.height / 2;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.beginPath();
      for (let i = 0; i < canvas.width; i++) {
        const segment = raw.slice(i * step, (i + 1) * step);
        const min = Math.min(...segment);
        const max = Math.max(...segment);
        ctx.moveTo(i, (1 + min) * amp);
        ctx.lineTo(i, (1 + max) * amp);
      }
      ctx.strokeStyle = '#000';
      ctx.stroke();
      drawPoints();
    }

    function drawPoints() {
      for (const pt of points) {
        const x = (pt.time / duration) * canvas.width;
        const y = canvas.height - pt.intensity * canvas.height;
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, Math.PI * 2);
        ctx.fillStyle = 'red';
        ctx.fill();
      }
    }

    function drawPlaybackPosition() {
      if (!audioElement || audioElement.paused) return;

      drawWaveform(audioBuffer);
      const x = (audioElement.currentTime / duration) * canvas.width;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvas.height);
      ctx.strokeStyle = 'blue';
      ctx.lineWidth = 2;
      ctx.stroke();

      animationId = requestAnimationFrame(drawPlaybackPosition);
    }

    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const time = (x / canvas.width) * duration;
      const intensity = 1 - (y / canvas.height);
      points.push({ time, intensity: Math.max(0, Math.min(1, intensity)) });
      drawWaveform(audioBuffer);
    });

    canvas.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const time = (x / canvas.width) * duration;
      points = points.filter(p => Math.abs(p.time - time) > 0.5);
      drawWaveform(audioBuffer);
    });

    playBtn.addEventListener('click', () => {
      if (audioElement) {
        audioElement.play();
        cancelAnimationFrame(animationId);
        drawPlaybackPosition();
      }
    });

    pauseBtn.addEventListener('click', () => {
      if (audioElement) {
        audioElement.pause();
        cancelAnimationFrame(animationId);
        drawWaveform(audioBuffer); // remove playhead line
      }
    });

    exportBtn.addEventListener('click', () => {
      const sorted = points.sort((a, b) => a.time - b.time);
      const csv = 'time,intensity\n' + sorted.map(p => `${p.time.toFixed(3)},${p.intensity.toFixed(2)}`).join('\n');
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'intensity.csv';
      a.click();
      URL.revokeObjectURL(url);
    });
  </script>
</body>
</html>
